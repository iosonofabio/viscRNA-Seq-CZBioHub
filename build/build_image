#!/usr/bin/env python
'''
Build an Amazon Machine Image (AMI) with the latest software using packer.
'''
import os
import sys
import json
import time
import subprocess as sp
import argparse
import random


class Builder:
    def find_packer(self):
        for packer in ('packer', 'packer-io'):
            try:
                sp.run([packer, '--version'], check=True)
                break
            except (FileNotFoundError, sp.CalledProcessError):
                continue
        else:
            raise IOError('Packer executable not found')
        self.packer = packer

    def validate_config(self):
        sp.run([self.packer, 'validate', 'build/viscrna-seq.json'],
               check=True)

    def get_ami_records(self):
        out = sp.run(' '.join([
            'aws', 'ec2', 'describe-images',
            '--filters',
            '"Name=tag:Project,Values=viscRNA-Seq"',
            '"Name=state,Values=available"',
            ]),
            shell=True,
            check=True,
            stdout=sp.PIPE).stdout.decode()
        ami_records = json.loads(out)

        # Reformat tags as a dictionary
        for rec in ami_records['Images']:
            if 'Tags' not in rec:
                rec['Tags'] = {}
            else:
                rec['Tags'] = {d['Key']: d['Value'] for d in rec['Tags']}
        return ami_records

    def find_ebs_from_description(self, substring):
        out = sp.run(
                ['aws', 'ec2', 'describe-snapshots'],
                check=True,
                stdout=sp.PIPE).stdout
        di = json.loads(out)
        for snap in di['Snapshots']:
            if 'Description' not in snap:
                continue
            if substring in snap['Description']:
                break
        else:
            raise ValueError('EBS volume not found')
        return snap['SnapshotId']

    def find_ebs_from_tags(self, tag_dict):
        out = sp.run(
                ['aws', 'ec2', 'describe-snapshots'],
                check=True,
                stdout=sp.PIPE).stdout
        di = json.loads(out)
        for snap in di['Snapshots']:
            if 'Tags' not in snap:
                continue
            found = True
            for key, val in tag_dict.items():
                if key not in snap['Tags']:
                    found = False
                elif snap['Tags'][key] != val:
                    found = False
            if found:
                break
        else:
            raise ValueError('EBS volume not found')
        return snap['SnapshotId']

    def deregister_ami(self, ami_id):
        sp.run(['aws', 'ec2', 'deregister-image', '--image-id', ami_id],
               check=True)
        ebs_id = self.find_ebs_from_description(ami_id)
        self.detach_ebs(ebs_id)

    def detach_ebs(self, ebs_id):
        sp.run(['aws', 'ec2', 'delete-snapshot', '--snapshot-id', ebs_id])

    def get_git_commit(self):
        git_commit = os.getenv('TRAVIS_COMMIT')
        if git_commit is None:
            git_commit = sp.run(
                    'git rev-parse HEAD',
                    shell=True,
                    check=True,
                    stdout=sp.PIPE).stdout.decode().rstrip('\n')
        return git_commit

    def get_compatible_ami(self):
        git_commit = self.get_git_commit()

        # If there is an AMI from a commit that has no diff in /build, recycle
        ami_records = self.get_ami_records()
        for ami_record in ami_records['Images']:
            git_commit_ami = ami_record['Tags']['GitCommit']
            out = sp.run(
                'git diff --name-only {:} {:}'.format(
                    git_commit_ami,
                    git_commit),
                shell=True,
                check=True,
                stdout=sp.PIPE,
                ).stdout.decode().split('\n')
            for line in out:
                if line.startswith('build/'):
                    break
            else:
                return ami_record['ImageId']

        return None

    def build_ami(self, dry=False):
        env = os.environ
        env['PACKER_LOG'] = 'true'

        # Generate unique token to delete the launch volume in case of failure
        # NOTE: this is redundant as packer has mechanisms to cover this corner,
        # but for the time being better safe than sorry
        token = str(random.randint(0, 1e10))
        env = os.environ
        env['VISCRNA-SEQ_PACKER_TOKEN'] = token
        print('VISCRNA-SEQ_PACKER_TOKEN: {:}'.format(token))

        if dry:
            print('Dry running of the AMI build step')
            return

        try:
            out = sp.run(' '.join([
                self.packer,
                '-machine-readable',
                'build',
                'build/viscrna-seq.json',
                ]),
                shell=True,
                check=True,
                env=env,
                stdout=sp.PIPE,
                ).stdout.decode()

            print('Check the presence of artifacts')
            if 'no artifacts were created' in out:
                raise RuntimeError('packer could not build artifacts')

            # Add the record to the AMI records
            out = out.split('\n')
            for i, line in enumerate(out):
                if 'The artifacts of successful builds are:' in line:
                    break
            else:
                raise RuntimeError('packer build failed for unknown reasons, see log')
            ami_id = out[i+3].split(',')[5].split(':')[1]
            print('AMI built: {:}'.format(ami_id))

        except RuntimeError:
            print('Ensuring detachment of EBS volume')
            found = True
            try:
                ebs_id = self.find_ebs_from_tags(
                        {'viscrnaseq_packer_token': token},
                        )
            except ValueError:
                found = False
            if found:
                self.detach_ebs(ebs_id)
            print('Volume detached')


if __name__ == '__main__':

    pa = argparse.ArgumentParser(
            description='AMI builder for viscRNA-Seq project',
            )
    pa.add_argument(
            '--dry', action='store_true',
            help='Dry run')
    args = pa.parse_args()

    print("PACKER BUILD")
    builder = Builder()

    print('Find packer')
    builder.find_packer()

    print('Validate packer config')
    builder.validate_config()

    print('Check whether rebuilding is necessary')
    ami_id = builder.get_compatible_ami()

    if ami_id is None:
        print('Build AMI')
        ami_id = builder.build_ami(dry=args.dry)
        print('New AMI built: {:}'.format(ami_id))

    else:
        print('No rebuild necessary, compatible AMI: {:}'.format(ami_id))
