#!/usr/bin/env python
'''
Build an Amazon Machine Image (AMI) with the latest software using packer.

When the image is built, we need to log it into a file to avoid polluting CZB's
Amazon space with undead EBS snapshots. We make two copies of that, just in case.

The first location is on:

s3://viscrna-seq/development/CI/log_AMIs.json

The backup copy is in

s3://fzanini-bucket/viscrna-seq-backup/log_AMIs.json

The format of the JSON file is the following:


{
  'AMIs':
    [{
      'id': 'dsalkjalsa',
      'timestamp': 2138021983021,
      'git-commits': ['dadsaf332ad'],
    },
    {
     ...
    }],
}


Of course this is redundant at the moment, but better safe than sorry.
'''
#TODO: add the backup bucket
import os
import sys
import json
import time
import subprocess as sp
import argparse
import random


class Builder:
    def find_packer(self):
        for packer in ('packer', 'packer-io'):
            try:
                sp.run([packer, '--version'], check=True)
                break
            except (FileNotFoundError, sp.CalledProcessError):
                continue
        else:
            raise IOError('Packer executable not found')
        self.packer = packer

    def validate_config(self):
        sp.run([self.packer, 'validate', 'build/viscrna-seq.json'],
               check=True)

    def get_ami_records(self):
        sp.run(['aws', 's3', 'cp',
                's3://viscrna-seq/development/CI/log_AMIs.json',
                'log_AMIs.json'],
               check=True)
        try:
            with open('log_AMIs.json', 'rt') as f:
                ami_records = json.load(f)
        finally:
            os.remove('log_AMIs.json')
        return ami_records

    def set_ami_records(self, ami_records):
        try:
            with open('log_AMIs.json', 'wt') as f:
                json.dump(ami_records, f)
            sp.run(['aws', 's3', 'rm',
                    's3://viscrna-seq/development/CI/log_AMIs.json'],
                   check=True,
                   )
            sp.run(['aws', 's3', 'cp',
                    'log_AMIs.json',
                    's3://viscrna-seq/development/CI/log_AMIs.json'],
                   check=True)
        finally:
            os.remove('log_AMIs.json')

    def append_ami_to_records(self, ami_record):
        records = self.get_ami_records()
        records['AMIs'].append(ami_record)
        self.set_ami_records(records)

    def find_ebs_from_description(self, substring):
        out = sp.run(
                ['aws', 'ec2', 'describe-snapshots'],
                check=True,
                stdout=sp.PIPE).stdout
        di = json.loads(out)
        for snap in di['Snapshots']:
            if 'Description' not in snap:
                continue
            if substring in snap['Description']:
                break
        else:
            raise ValueError('EBS volume not found')
        return snap['SnapshotId']

    def find_ebs_from_tags(self, tag_dict):
        out = sp.run(
                ['aws', 'ec2', 'describe-snapshots'],
                check=True,
                stdout=sp.PIPE).stdout
        di = json.loads(out)
        for snap in di['Snapshots']:
            if 'Tags' not in snap:
                continue
            found = True
            for key, val in tag_dict.items():
                if key not in snap['Tags']:
                    found = False
                elif snap['Tags'][key] != val:
                    found = False
            if found:
                break
        else:
            raise ValueError('EBS volume not found')
        return snap['SnapshotId']

    def deregister_ami(self, ami_id):
        sp.run(['aws', 'ec2', 'deregister-image', '--image-id', ami_id],
               check=True)
        ebs_id = self.find_ebs_from_description(ami_id)
        self.detach_ebs(ebs_id)

    def detach_ebs(self, ebs_id):
        sp.run(['aws', 'ec2', 'delete-snapshot', '--snapshot-id', ebs_id])

    def get_git_commit(self):
        git_commit = sp.run(
                'git rev-parse HEAD',
                shell=True,
                check=True,
                stdout=sp.PIPE).stdout.decode().rstrip('\n')
        return git_commit

    def get_compatible_ami(self):
        git_commit = self.get_git_commit()

        # If there is any AMI with ANY commit that has no diff in the
        # build folder, it's our lucky day
        ami_records = self.get_ami_records()
        for ami_record in ami_records['AMIs'][::-1]:
            for git_commit_ami in ami_record['git-commits'][::-1]:
                out = sp.run(
                    'git diff --name-only {:} {:}'.format(
                        git_commit_ami,
                        git_commit),
                    shell=True,
                    stdout=sp.PIPE,
                    ).stdout.decode().split('\n')
                for line in out:
                    if line.startswith('build/'):
                        break
                else:
                    # Check that AMI is really on AWS
                    try:
                        out = sp.run(' '.join([
                            'aws', 'ec2',
                            'describe-images',
                            '--image-ids', '"{:}"'.format(ami_record['id']),
                            ]),
                            shell=True,
                            chek=True)
                    except sp.CalledProcessError:
                        continue

                    return ami_record['id']

        return None

    def append_commit(self, ami_id, dry=False):
        git_commit = self.get_git_commit()
        ami_records = self.get_ami_records()
        for ami_record in ami_records['AMIs'][::-1]:
            if ami_record['id'] == ami_id:
                ami_record['git-commits'].append(git_commit)
                if dry:
                    print('Dry: upload updated AMI records')
                    return
                else:
                    return self.set_ami_records(ami_records)

        raise ValueError('AMI record not found!')

    def build_ami(self, dry=False):
        env = os.environ
        env['PACKER_LOG'] = 'true'

        # Generate unique token to delete the launch volume in case of failure
        # NOTE: this is redundant as packer has mechanisms to cover this corner,
        # but for the time being better safe than sorry
        token = str(random.randint(0, 1e10))
        env = os.environ
        env['VISCRNA-SEQ_PACKER_TOKEN'] = token
        print('VISCRNA-SEQ_PACKER_TOKEN: {:}'.format(token))

        if dry:
            print('Dry running of the AMI build step')
            return

        try:
            proc = sp.run(' '.join([
                self.packer,
                '-machine-readable',
                'build',
                'build/viscrna-seq.json',
                '|',
                'tee',
                'packer.log',
                ]),
                shell=True,
                env=env,
                )
            if proc.returncode:
                raise RuntimeError('packer build exit with code {:}, aborting'.format(
                    proc.returncode))

            # Check the presence of artifacts
            with open('packer.log', 'rt') as f:
                out = f.read()
            if 'no artifacts were created' in out:
                raise RuntimeError('packer could not build artifacts')

            # Add the record to the AMI records
            out = out.split('\n')
            for i, line in enumerate(out):
                if 'The artifacts of successful builds are:' in line:
                    break
            else:
                raise RuntimeError('packer build failed for unknown reasons, see log')
            ami_id = out[i+3].split(',')[5].split(':')[1]
            print('AMI built: {:}'.format(ami_id))

        except RuntimeError:
            print('Ensuring detachment of EBS volume')
            found = True
            try:
                ebs_id = self.find_ebs_from_tags(
                        {'viscrnaseq_packer_token': token},
                        )
            except ValueError:
                found = False
            if found:
                self.detach_ebs(ebs_id)
            print('Volume detached')
            return

        # If the AMI does not make it into the records for ANY reasons,
        # we better make triple sure we kill it
        try:
            timestamp = str(time.time())
            git_commit = self.get_git_commit()
            self.append_ami_to_records({
                'id': ami_id,
                'timestamp': timestamp,
                'git-commits': [git_commit],
                })
        except:
            self.deregister_ami(ami_id)
            raise


if __name__ == '__main__':

    pa = argparse.ArgumentParser(
            description='AMI builder for viscRNA-Seq project',
            )
    pa.add_argument(
            '--dry', action='store_true',
            help='Dry run')
    args = pa.parse_args()

    print("PACKER BUILD")
    builder = Builder()

    print('Find packer')
    builder.find_packer()

    print('Validate packer config')
    builder.validate_config()

    print('Check whether rebuilding is necessary')
    ami_id = builder.get_compatible_ami()

    if ami_id is None:
        print('Build AMI')
        ami_id = builder.build_ami(dry=args.dry)
        print('New AMI built: {:}'.format(ami_id))

    else:
        print('Compatible AMI found: {:}'.format(ami_id))
        builder.append_commit(ami_id, dry=args.dry)
