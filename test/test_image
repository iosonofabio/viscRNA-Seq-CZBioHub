#!/usr/bin/env python
'''
Test the user script of the readily built AMI on the mock dataset.

See build/build_image for the format of the AMI records.

The datast records have the following format:

{
 'id': <unique id>,
 'description': <optional description>,
 'path': 's3://<S3 address to tgz>,
}
'''
import os
import stat
import sys
import json
import time
import subprocess as sp


class Tester:
    def get_test_dataset_record(self):
        '''Get the record for the test dataset.

        NOTE: here we need to design an interface for the user that combines
        unique addressing with easy-to-remember for humans.

        NOTE: we do NOT pull out the data here!! The AMI does it there.
        '''
        # Use 10X-genomics tiny BCL file
        return {
                'id': '10X',
                'description': 'Test dataset from 10X Genomics',
                'data_path': 'http://cf.10xgenomics.com/supp/cell-exp/cellranger-tiny-bcl-1.2.0.tar.gz',
                'samplesheet_path': 'http://cf.10xgenomics.com/supp/cell-exp/cellranger-tiny-bcl-samplesheet-1.2.0.csv',
                'platform': '10X-singlecell-v2',
                }

    def get_git_commit(self):
        git_commit = os.getenv('TRAVIS_COMMIT')
        if git_commit is None:
            git_commit = sp.run(
                    'git rev-parse HEAD',
                    shell=True,
                    check=True,
                    stdout=sp.PIPE).stdout.decode().rstrip('\n')
        return git_commit

    def get_ami_records(self):
        out = sp.run(' '.join([
            'aws', 'ec2', 'describe-images',
            '--filters',
            '"Name=tag:Project,Values=viscRNA-Seq"',
            '"Name=state,Values=available"',
            ]),
            shell=True,
            check=True,
            stdout=sp.PIPE).stdout.decode()
        ami_records = json.loads(out)

        # Reformat tags as a dictionary
        for rec in ami_records['Images']:
            if 'Tags' not in rec:
                rec['Tags'] = {}
            else:
                rec['Tags'] = {d['Key']: d['Value'] for d in rec['Tags']}
        return ami_records

    def get_compatible_ami(self):
        git_commit = self.get_git_commit()

        # If there is an AMI from a commit that has no diff in /build, recycle
        ami_records = self.get_ami_records()
        for ami_record in ami_records['Images']:
            git_commit_ami = ami_record['Tags']['GitCommit']
            out = sp.run(
                'git diff --name-only {:} {:}'.format(
                    git_commit_ami,
                    git_commit),
                shell=True,
                check=True,
                stdout=sp.PIPE,
                ).stdout.decode().split('\n')
            for line in out:
                if line.startswith('build/'):
                    break
            else:
                return ami_record['ImageId']

        return None

    def transpile_pipeline(self):
        git_commit = os.getenv('TRAVIS_COMMIT')
        git_branch = os.getenv('TRAVIS_BRANCH')
        ami_id = self.get_compatible_ami()

        # Fill the globals in the script
        fn_in = 'run/viscrna-seq-pipeline'
        fn_out = 'viscrna-seq-pipeline'
        with open(fn_in, 'rt') as fin:
            with open(fn_out, 'wt') as fout:
                for line in fin:
                    if line.startswith('VISCRNASEQ_GIT_COMMIT = '):
                        fout.write('VISCRNASEQ_GIT_COMMIT = {:}\n'.format(
                            git_commit))
                    elif line.startswith('VISCRNASEQ_GIT_BRANCH = '):
                        fout.write('VISCRNASEQ_GIT_BRANCH = {:}\n'.format(
                            git_branch))
                    if line.startswith('VISCRNASEQ_AMI_ID = '):
                        fout.write('VISCRNASEQ_AMI_ID = {:}\n'.format(
                            ami_id))
                    else:
                        fout.write(line)

        # chmod u+x transpiled file
        st = os.stat(fn_out)
        os.chmod(fn_out, st.st_mode | stat.S_IEXEC)

    def test_ami(self):
        dataset_record = self.get_test_dataset_record()
        call = ' '.join([
            './viscrna-seq-pipeline',
            '--input-data', dataset_record['data_path'],
            '--input-samplesheet', dataset_record['samplesheet_path'],
            '--output', 'none',
            '--output-gdrive', 'none',
            '--id', dataset_record['id'],
            ])
        print(call)
        sp.run(
            call,
            shell=True,
            check=True,
            )


if __name__ == '__main__':

    print('TESTER')
    tester = Tester()

    print('TRANSPILE PIPELINE')
    tester.transpile_pipeline()

    print('TEST PIPELINE ON MACA DATA')
    tester.test_ami()

    print('Done. All good')
